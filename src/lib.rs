#![feature(min_specialization)]

use std::io::Read;

use anyhow::{anyhow, Result};
use sha2::{Digest, Sha256};
use turbo_tasks_fs::{DiskFileSystemVc, File, FileContent, FileSystemPathVc};

// Create a reactive wrapper around String values. This creates 2 structs, a
// `StringValue` (which is exactly the single-tuple struct you see below), and a
// `StringValueVc` "value cell" wrapper. The Vc is the thing that allows us to
// track dependencies of the current function.
#[turbo_tasks::value(transparent)]
struct StringValue(String);

#[turbo_tasks::function]
pub async fn tailwind(cwd: String) -> Result<()> {
    // Create a reactive Disk File System Vc.
    // This is a concrete struct which implements the FileSystem trait over
    // a real location on disk.
    let disk_fs = DiskFileSystemVc::new("description".to_string(), cwd);
    // Start FS watching. Any writes to files we read will automatically recompute
    // functions which awaited on that read.
    disk_fs.await?.start_watching()?;

    // Cast to our generic FileSystem trait, which implements path/read methods.
    let fs = disk_fs.as_file_system();

    // Create a FileSystemPathVc pointing to a "[CWD]/README.md" file.
    let input = fs.root().join("README.md");

    // Pass our path into a helper function as input, and receive some output.
    let hash = hash_file(input);

    // We can await any function inputs/outputs to "read" their value. Reading
    // a value makes it a dependency of this function's computation, and any changes
    // to the value will cause this function to recompute.
    println!("HASH: {}", hash.await?.as_str());

    Ok(())
}

#[turbo_tasks::function]
async fn hash_file(file_path: FileSystemPathVc) -> Result<StringValueVc> {
    // Read the file. Because we're reading from a path that was created from our
    // watched DiskFileSystem, this file is automatically watched.
    let content = file_path.read().await?;

    match &*content {
        FileContent::Content(file) => {
            let hash = hash_content(file);
            // Return a reactive StringValue Vc of our hash. Outputs (and inputs) to a Turbo
            // function must be Vcs, so that we can create the dependency graph when we read
            // a value.
            Ok(StringValueVc::cell(hash))
        }
        FileContent::NotFound => {
            // File doesn't currently exist on disk. If it's saved later, we'll detect that.
            Err(anyhow!("file doesn't exist on disk"))
        }
    }
}

// This is just a regular function. It won't be "reactive", but it's still
// useful to break up large reactive functions. If called from a Turbo function,
// then that function will record any reactive dependencies we await (if we
// awaited any).
fn hash_content(file: &File) -> String {
    let mut hasher = Sha256::new();
    let mut buf = [0; 1024];
    // Get a std::io::Read instance, like a Node stream.
    let mut reader = file.read();
    while let Ok(size) = reader.read(&mut buf) {
        if size == 0 {
            break;
        }
        hasher.update(&buf[0..size]);
    }

    // Format the hash into a hex string
    format!("{:x}", hasher.finalize())
}

// The register function (the name "register" is a convention) informs the turbo engine of all
// possible value types and functions. The register should also call the register of every turbo
// crate which you import, and include the automatically generated output file "register.rs".
pub fn register() {
    turbo_tasks::register();
    turbo_tasks_fs::register();
    // this file is generated by our build.rs build script.
    include!(concat!(env!("OUT_DIR"), "/register.rs"));
}

#![feature(arbitrary_self_types)]
#![feature(async_fn_in_trait)]
#![feature(min_specialization)]

use std::io::Read;

use anyhow::{anyhow, Result};
use sha2::{Digest, Sha256};
use turbo_tasks::Vc;
use turbo_tasks_fs::{DiskFileSystem, File, FileContent, FileSystem, FileSystemPath};

// Create a reactive wrapper around String values. This is just a simple tuple
// struct, but it has the ability to be wrapped in Vc. The Vc wrapper is the
// thing that allows us to track dependencies of the current function.
// This isn't strictly necessary, Strings and other primitive values can be
// wrapped in a Vc without a wrapper struct, but this is just to demo.
#[turbo_tasks::value(transparent)]
struct StringValue(String);

#[turbo_tasks::function]
pub async fn tailwind(cwd: String) -> Result<()> {
    // This is a concrete struct which implements the FileSystem turbo trait over a
    // real location on disk.
    let disk_fs = DiskFileSystem::new("description".to_string(), cwd);
    // Start FS watching. Any writes to files we read will automatically recompute
    // functions which awaited on that read.
    disk_fs.await?.start_watching()?;

    // Cast to our generic FileSystem trait, which implements path/read methods.
    let fs: Vc<Box<dyn FileSystem>> = Vc::upcast(disk_fs);

    // Create a Vc<FileSystemPath> pointing to a "[CWD]/README.md" file.
    let input = fs.root().join("README.md".to_string());

    // Pass our path into a helper function as input, and receive some output.
    let hash = hash_file(input);

    // We can await any function inputs/outputs to "read" their value. Reading
    // a value makes it a dependency of this function's computation, and any changes
    // to the value will cause this function to recompute.
    println!("HASH: {}", hash.await?.as_str());

    Ok(())
}

#[turbo_tasks::function]
async fn hash_file(file_path: Vc<FileSystemPath>) -> Result<Vc<StringValue>> {
    // Read the file. Because we're reading from a path that was created from our
    // watched DiskFileSystem, this file is automatically watched.
    let content = file_path.read().await?;

    match &*content {
        FileContent::Content(file) => {
            let hash = hash_content(file);
            // Return a reactive Vc<StringValue> of our hash. Outputs (and inputs) to a
            // Turbo function must be Vcs, so that we can create the dependency
            // graph when we read a value.
            Ok(Vc::cell(hash))
        }
        FileContent::NotFound => {
            // File doesn't currently exist on disk. If it's saved later, we'll detect that.
            Err(anyhow!("file doesn't exist on disk"))
        }
    }
}

// This is just a regular function. It won't be "reactive", but it's still
// useful to break up large reactive functions. If called from a Turbo function,
// then that function will record any reactive dependencies we await (if we
// awaited any).
fn hash_content(file: &File) -> String {
    let mut hasher = Sha256::new();
    let mut buf = [0; 1024];
    // Get a std::io::Read instance, like a Node stream.
    let mut reader = file.read();
    while let Ok(size) = reader.read(&mut buf) {
        if size == 0 {
            break;
        }
        hasher.update(&buf[0..size]);
    }

    // Format the hash into a hex string
    format!("{:x}", hasher.finalize())
}

// The register function (the name "register" is a convention) informs the turbo
// engine of all possible value types and functions. The register should also
// call the register of every turbo crate which you import, and include the
// automatically generated output file "register.rs".
pub fn register() {
    turbo_tasks::register();
    turbo_tasks_fs::register();
    // this file is generated by our build.rs build script.
    include!(concat!(env!("OUT_DIR"), "/register.rs"));
}
